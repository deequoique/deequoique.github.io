[{"categories":["考研日记"],"content":"6/1 SAT awake：9am asleep： 😭😭😭😭😭😭 ","date":"2024-06-01","objectID":"/6%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95w1/:1:0","tags":[],"title":"6月考研记录w1","uri":"/6%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95w1/"},{"categories":["考研日记"],"content":"计划与进度 高数 chapter5、6 最值或取值范围 作函数图像 曲率及曲率半径 chapter5习题 中值定理 数据结构 chapter5 树与二叉树 树、森林 树与二叉树的应用 英语 单词100/100 复盘 函数图像和习题囫囵吞枣了一下，因为今天厌学情绪上来了，崩溃了大半天，下午才缓过劲来。 为哄自己学习把直播弄上了。 ","date":"2024-06-01","objectID":"/6%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95w1/:1:1","tags":[],"title":"6月考研记录w1","uri":"/6%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95w1/"},{"categories":["考研日记"],"content":"6/2 SUN awake: asleep: ","date":"2024-06-01","objectID":"/6%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95w1/:2:0","tags":[],"title":"6月考研记录w1","uri":"/6%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95w1/"},{"categories":["考研日记"],"content":"计划与进度 高数 chapter6 一元函数微分学的应用 中值定理 数据结构 图的基本概念 图的存储及基本操作 英语 单词0/100 ","date":"2024-06-01","objectID":"/6%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95w1/:2:1","tags":[],"title":"6月考研记录w1","uri":"/6%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95w1/"},{"categories":["考研日记"],"content":"\r作息时间表（五月、六月）\r08:30 - 9:30 起床吃饭，制定一天计划表 09:30 - 11:30 数学 13:30 - 15:30 数学 16:00 - 18:00 408 20:00 - 22:00 英语 22:00 - 22:30 写复盘总结 总的来说两个小时进行一个长时间歇息，中间采用番茄钟休息法，小的休息方式为健身，长时间吉他。 8点半起床，12点睡觉。 ","date":"2024-05-27","objectID":"/%E8%80%83%E7%A0%94%E6%97%B6%E9%97%B4%E8%A1%A8/:0:0","tags":[],"title":"考研计划","uri":"/%E8%80%83%E7%A0%94%E6%97%B6%E9%97%B4%E8%A1%A8/"},{"categories":["考研日记"],"content":"5/27 MON awake：9am asleep：2am ","date":"2024-05-27","objectID":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/:0:0","tags":[],"title":"5月考研记录","uri":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/"},{"categories":["考研日记"],"content":"计划与进度 高数：张宇chapter4：基本求导、四则运算、复合函数导数与微分形式不变性、分段函数的导数、反函数导数 ✅例题4.7 ❌ 英语：背单词100 50/100 ❌ 数据结构：chapter4 串 ❌ ","date":"2024-05-27","objectID":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/:1:0","tags":[],"title":"5月考研记录","uri":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/"},{"categories":["考研日记"],"content":"心情 🤗 ","date":"2024-05-27","objectID":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/:2:0","tags":[],"title":"5月考研记录","uri":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/"},{"categories":["考研日记"],"content":"杂谈 今天梁老板农历生日，弄了个长得还可以的蛋糕嘿嘿 中午看到圆律发的逆天视频，和zyj讨论，遂被安利了调研incel群体的视频，还是蛮感慨的，毕竟很难看到这样的角度去讨论性别问题。之后在阿b和小红书上分别看了看评论区的气氛，还有他们吵架的内容。信息茧房和用户群体可见一斑…… 怎么说呢，时隔多年再次写起日记，发现自己果然丧失了很多表达的能力。有些事和话不知道怎么说，无法输出，也没有什么感想。 嗯，总之再写写吧。 明天要健身。 ","date":"2024-05-27","objectID":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/:3:0","tags":[],"title":"5月考研记录","uri":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/"},{"categories":["考研日记"],"content":"总结 今天unfinished的原因是弄博客的时候没想到困难丛生（主要是因为sub module的问题，我都不知道什么时候设置的），顺带学了一下git action。 明天要回学校，准备后天的毕业照，所以应该也不能完成多少任务了。 5/28 TUES awake：11am asleep：1am ","date":"2024-05-27","objectID":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/:4:0","tags":[],"title":"5月考研记录","uri":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/"},{"categories":["考研日记"],"content":"计划与进度 回学校拍毕业照，休息一天 ","date":"2024-05-27","objectID":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/:5:0","tags":[],"title":"5月考研记录","uri":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/"},{"categories":["考研日记"],"content":"心情 😖 ","date":"2024-05-27","objectID":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/:6:0","tags":[],"title":"5月考研记录","uri":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/"},{"categories":["考研日记"],"content":"总结 和zyj玩去了，，，， 5/29 WES awake：7am asleep：2am ","date":"2024-05-27","objectID":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/:7:0","tags":[],"title":"5月考研记录","uri":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/"},{"categories":["考研日记"],"content":"计划与进度 高数：chapter4看完书和课 （看了一半左右，，） ❌ 数据结构：chapter4 串 ✅ 英语: 背单词66/100 ","date":"2024-05-27","objectID":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/:8:0","tags":[],"title":"5月考研记录","uri":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/"},{"categories":["考研日记"],"content":"心情 😪 ","date":"2024-05-27","objectID":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/:9:0","tags":[],"title":"5月考研记录","uri":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/"},{"categories":["考研日记"],"content":"杂谈 什么时候能在学校行政处的坟头蹦迪你这一生就圆满了wtl，，，，， 又白白浪费了一上午。 早上七点起床实在是太困。。 ","date":"2024-05-27","objectID":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/:10:0","tags":[],"title":"5月考研记录","uri":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/"},{"categories":["考研日记"],"content":"总结 数据结构KMP算法使我的大脑飞速运转。感觉之后还需要巩固。 5/30 THU awake：10.5am asleep：1am ","date":"2024-05-27","objectID":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/:11:0","tags":[],"title":"5月考研记录","uri":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/"},{"categories":["考研日记"],"content":"计划与进度 高数：chapter4看完书和课，做完题 ✅ 数据结构:5.1 5.2 ✅ 英语：背单词100/100 ✅ ","date":"2024-05-27","objectID":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/:12:0","tags":[],"title":"5月考研记录","uri":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/"},{"categories":["考研日记"],"content":"心情 ✅ ","date":"2024-05-27","objectID":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/:13:0","tags":[],"title":"5月考研记录","uri":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/"},{"categories":["考研日记"],"content":"杂谈 小红书搜了搜数学听哪个老师的，结果就开始给我推焦虑信息，发现人家都学完高数和数据结构了，我这高数才学了4章，，开始狠狠焦虑。 不行，还是要按自己的节奏来。 ","date":"2024-05-27","objectID":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/:14:0","tags":[],"title":"5月考研记录","uri":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/"},{"categories":["考研日记"],"content":"总结 感觉一周要分配一天做每周复习。改一下计划。 每天背高数公式提上日程。 5/30 THU awake：8.5am asleep：2am ","date":"2024-05-27","objectID":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/:15:0","tags":[],"title":"5月考研记录","uri":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/"},{"categories":["考研日记"],"content":"计划与进度 高数：chapter5 微分学几何应用：极值定义、单调性与极值判别、凹凸性与拐点概念与判别。第四讲需要背的整理背诵。✅超额完成，渐近线也看完了。明天直接第6讲开启~ 数据结构：chapter5 树 over —— over不了了，只写了二叉树遍历。写了4个多小时。❌ 英语：背单词100/100 ✅ ","date":"2024-05-27","objectID":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/:16:0","tags":[],"title":"5月考研记录","uri":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/"},{"categories":["考研日记"],"content":"总结 😵 数据结构要被线索树折磨死了。。。。我恨二叉树，，，43道题硬控我一晚上。 天地良心喵，学数据结构时间比高数还要长 ","date":"2024-05-27","objectID":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/:17:0","tags":[],"title":"5月考研记录","uri":"/5%E6%9C%88%E8%80%83%E7%A0%94%E8%AE%B0%E5%BD%95/"},{"categories":["码农日记"],"content":"策略模式（Strategy Pattern）是一种行为设计模式，它使你能够定义一系列的算法，将每一个算法封装起来，并使它们可以互换使用。策略模式让算法的变化独立于使用算法的客户。这种模式是一种对象行为模式，用于定义一系列的算法，并将每一个算法封装起来，使它们可以相互替换。 主要特点和优点包括： 定义一系列算法：可以定义一系列的操作或算法。 封装和替换：每个算法被封装在不同的策略类中，并且这些策略类可以相互替换。 避免多重条件选择语句：策略模式提供了一种避免使用多重条件选择语句的方法。 扩展性良好：增加新的策略类不会影响到使用策略的类。 我们用HomePageManager做一个示范 ","date":"2024-01-20","objectID":"/spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/:0:0","tags":["JAVA"],"title":"Spring框架中优雅地使用策略模式","uri":"/spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["码农日记"],"content":"1. 策略管理器（Manager） HomePageManager 类是策略管理器。它负责维护不同策略的注册，并提供方法来匹配合适的策略。 package org.reachplatform.idea.service.strategy; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Component; import java.util.Map; import java.util.concurrent.ConcurrentHashMap; @Component @Slf4j public class HomePageManager { private static Map\u003cString, HomePageStrategy\u003e map = new ConcurrentHashMap\u003c\u003e(); public static void register(String mark, HomePageStrategy strategy) { map.put(mark, strategy); } public static HomePageStrategy matchHandler(String mark) { if (mark.equals(\"\")) { log.error(\"Matching handler failed\"); } return map.get(mark); } } ","date":"2024-01-20","objectID":"/spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/:0:1","tags":["JAVA"],"title":"Spring框架中优雅地使用策略模式","uri":"/spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["码农日记"],"content":"2. 抽象策略接口 HomePageStrategy 接口定义了策略的操作。不同的策略实现将提供这些操作的具体实现。 package org.reachplatform.idea.service.strategy; import org.reachplatform.idea.controller.entity.es.ESIdeaPO; import org.springframework.data.domain.Page; public interface HomePageStrategy { Page\u003cESIdeaPO\u003e page(String current, String size); } ","date":"2024-01-20","objectID":"/spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/:0:2","tags":["JAVA"],"title":"Spring框架中优雅地使用策略模式","uri":"/spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["码农日记"],"content":"3. 抽象类用于注册 AbstractPage 类提供了一个抽象方法 register，用于在子类中实现策略的注册逻辑。 public abstract class AbstractPage { public abstract void register(); } ","date":"2024-01-20","objectID":"/spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/:0:3","tags":["JAVA"],"title":"Spring框架中优雅地使用策略模式","uri":"/spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["码农日记"],"content":"4. 策略实现类 RecommendHandler 类实现了 HomePageStrategy 接口和 AbstractPage 抽象类。它提供了策略的具体实现，并在创建时注册自己。 import javax.annotation.PostConstruct; public class RecommendHandler extends AbstractPage implements HomePageStrategy { @Override @PostConstruct public void register() { HomePageManager.register(DataConstant.RECOMMEND, this); } @Override public Page\u003cESIdeaPO\u003e page(String current, String size) { return null; } } 在这个示例中，@PostConstruct 注解的作用是确保在构造函数执行后立即调用 register 方法，从而将实例注册到管理器中。 以上就是策略模式在 Java 中的一个示例实现，其中展示了如何定义策略接口、实现不同的策略，并通过一个管理器类来动态选择使用哪个策略。 ","date":"2024-01-20","objectID":"/spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/:0:4","tags":["JAVA"],"title":"Spring框架中优雅地使用策略模式","uri":"/spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["码农日记"],"content":"Elasticsearch 是一个开源的、高度可扩展的、全文搜索和分析引擎，它能够快速、近实时地存储、搜索和分析大量数据。Elasticsearch 常用于日志和事件数据分析、全文搜索、安全智能分析以及业务智能等场景。 ","date":"2024-01-08","objectID":"/elastic-searchesspringboot-%E5%B0%8F%E7%99%BD%E6%95%99%E7%A8%8B/:0:0","tags":["JAVA","ES"],"title":"Elastic Search（ES）Springboot 小白教程","uri":"/elastic-searchesspringboot-%E5%B0%8F%E7%99%BD%E6%95%99%E7%A8%8B/"},{"categories":["码农日记"],"content":"1. 添加依赖 maven: \u003cdependencies\u003e \u003c!-- Spring Data Elasticsearch --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-elasticsearch\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- Other dependencies --\u003e \u003c/dependencies\u003e ","date":"2024-01-08","objectID":"/elastic-searchesspringboot-%E5%B0%8F%E7%99%BD%E6%95%99%E7%A8%8B/:1:0","tags":["JAVA","ES"],"title":"Elastic Search（ES）Springboot 小白教程","uri":"/elastic-searchesspringboot-%E5%B0%8F%E7%99%BD%E6%95%99%E7%A8%8B/"},{"categories":["码农日记"],"content":"2. 配置连接信息 在application.properties或application.yml中配置Elasticsearch的连接信息。 # application.properties spring.elasticsearch.rest.uris=http://localhost:9200 spring.elasticsearch.rest.username=user # 如果需要的话 spring.elasticsearch.rest.password=pass # 如果需要的话 ","date":"2024-01-08","objectID":"/elastic-searchesspringboot-%E5%B0%8F%E7%99%BD%E6%95%99%E7%A8%8B/:2:0","tags":["JAVA","ES"],"title":"Elastic Search（ES）Springboot 小白教程","uri":"/elastic-searchesspringboot-%E5%B0%8F%E7%99%BD%E6%95%99%E7%A8%8B/"},{"categories":["码农日记"],"content":"3. 定义实体类 创建一个实体类，使用@Document注解标记它，以表示它是一个Elasticsearch文档。 这里文档可以理解成和MySQL中entity一样的东西。 例如 import org.springframework.data.annotation.Id; import org.springframework.data.elasticsearch.annotations.Document; @Document(indexName = \"blog\", type = \"article\") public class ESIdeaPO { @Id private String address; private String title; private String content; private String type; } ","date":"2024-01-08","objectID":"/elastic-searchesspringboot-%E5%B0%8F%E7%99%BD%E6%95%99%E7%A8%8B/:3:0","tags":["JAVA","ES"],"title":"Elastic Search（ES）Springboot 小白教程","uri":"/elastic-searchesspringboot-%E5%B0%8F%E7%99%BD%E6%95%99%E7%A8%8B/"},{"categories":["码农日记"],"content":"4. 创建Repository接口 创建一个继承ElasticsearchRepository的接口，Spring Data Elasticsearch将自动实现基本的CRUD操作。 就像Mybatis-plus的IService一样 import org.springframework.data.elasticsearch.repository.ElasticsearchRepository; public interface ArticleRepository extends ElasticsearchRepository\u003cESIdeaPO, String\u003e { // 可以添加自定义的查询方法 } 比较神奇的点是在，定义一个方法后不需要实现它，只要按特定格式写就可以。 比如方法名叫做：findByTitle，那么它就知道你是根据title查询，然后自动帮你完成，无需写实现类。 ","date":"2024-01-08","objectID":"/elastic-searchesspringboot-%E5%B0%8F%E7%99%BD%E6%95%99%E7%A8%8B/:4:0","tags":["JAVA","ES"],"title":"Elastic Search（ES）Springboot 小白教程","uri":"/elastic-searchesspringboot-%E5%B0%8F%E7%99%BD%E6%95%99%E7%A8%8B/"},{"categories":["码农日记"],"content":"5. 编写服务层 可以使用这个Respository编写需要的crud了 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; @Service public class ArticleService { @Autowired private ArticleRepository articleRepository; public void save(Article article) { articleRepository.save(article); } public Iterable\u003cArticle\u003e findByTitle(String title) { return articleRepository.findByTitle(title); } // 其他业务方法 } 总结 在SpringBoot的加持下，使用感和各种数据库大差不差。初步了解像是那种可以专门用来搜索，且不用担心效率和索引的数据库。 ","date":"2024-01-08","objectID":"/elastic-searchesspringboot-%E5%B0%8F%E7%99%BD%E6%95%99%E7%A8%8B/:5:0","tags":["JAVA","ES"],"title":"Elastic Search（ES）Springboot 小白教程","uri":"/elastic-searchesspringboot-%E5%B0%8F%E7%99%BD%E6%95%99%E7%A8%8B/"},{"categories":["杂谈"],"content":"和杨绛老师谐个音吧。 忽然写这个的原因是收到然的消息，刘姐保了本校的硕士，由哲学系转去法学，她俩计划在假期一起吃顿饭，但也不一定真的会吃。按理来说这顿饭应该也有我的一份，但是由于某些事情，我和刘姐已经再也不会联系对方了。 我和然跟刘姐是高中同学，然跟刘姐是初中同学，然跟刘姐不算高中同学。因为文理分班之后，我和刘姐才相遇在同一个班里，而然则在文科班。 不过话说回来，如果这顿饭有我的一份，那就必然是会吃了。之所以这么说的原因，是因为我在她们两个中间的关系就是这样的。 离开高中已经快四年，我们的前程也大致确定了下来，各自精彩。 然是本科最好的，去了FDU，在大三那年选择降转到小语种，于是目前仍是大二，明年出国。刘姐则是SCU，化学系录取，申请了哲学英才本硕博，而又奔向社科的终点法学。而我在HIT——SZ，混了三年自学成一名JAVA仔，即将去武汉。 所以我在难过什么呢？三年前我们三个聚在一起，信誓旦旦毕业怎么也要去对方的城市住一起养老。两年前刘姐已经不再与我说话，我则发誓不管怎样她去哪我去哪，反正写代码好找工作，总会有让她开口与我讲话的一天。而这一年的秋招互联网开始了寒冬。然也在这一疫情年，对此地的社科彻底失去希望，转而行向语言之“润”土。 所以我们三个就是这样了，也许缘分至此，再没有别的结局。 ","date":"2024-01-04","objectID":"/%E6%88%91%E4%BB%AC%E4%B8%89/:0:0","tags":[],"title":"我们三","uri":"/%E6%88%91%E4%BB%AC%E4%B8%89/"},{"categories":["码农日记"],"content":"1. 引入MyBatis- plus依赖 ","date":"2024-01-02","objectID":"/mybatis-plus%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/:0:1","tags":["JAVA"],"title":"MyBatis Plus分页查询","uri":"/mybatis-plus%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/"},{"categories":["码农日记"],"content":"2. 配置分页插件 在你的配置类中添加分页插件。MyBatis-Plus 提供了一个分页拦截器 PaginationInterceptor，你需要将它配置为一个 Bean。 @Configuration public class MybatisPlusConfig { @Bean public PaginationInterceptor paginationInterceptor() { return new PaginationInterceptor(); } } ","date":"2024-01-02","objectID":"/mybatis-plus%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/:0:2","tags":["JAVA"],"title":"MyBatis Plus分页查询","uri":"/mybatis-plus%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/"},{"categories":["码农日记"],"content":"3. 使用分页 在你的Mapper接口中，你可以直接使用 MyBatis-Plus 提供的 selectPage 方法进行分页查询。通常，你需要传入一个 Page 对象作为查询参数，Page 对象包含了分页需要的信息如当前页码和每页显示的数量。 public interface UserMapper extends BaseMapper\u003cUser\u003e { // 其他CRUD操作 } @Service public class UserService { @Autowired private UserMapper userMapper; public IPage\u003cUser\u003e selectUserPage(Page\u003cUser\u003e page, Integer state) { return userMapper.selectPage(page, new QueryWrapper\u003cUser\u003e().eq(\"state\",state)); } } 在调用时，你只需要创建一个 Page 对象，设置好相应的页码和每页数量，然后将它作为参数传递给方法即可。 ","date":"2024-01-02","objectID":"/mybatis-plus%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/:0:3","tags":["JAVA"],"title":"MyBatis Plus分页查询","uri":"/mybatis-plus%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/"},{"categories":["码农日记"],"content":"4. 处理结果 selectPage 方法返回的 IPage 对象包含了分页查询的结果，你可以从中获取到查询到的记录以及分页的详细信息，例如总页数、总记录数等。 ","date":"2024-01-02","objectID":"/mybatis-plus%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/:0:4","tags":["JAVA"],"title":"MyBatis Plus分页查询","uri":"/mybatis-plus%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/"},{"categories":["码农日记"],"content":"以vscode为例，在项目根文件夹建立.vscode文件夹，文件夹内创建tasks.json文件，内容如下 { \"label\": \"Publish Blog\", \"type\": \"shell\", \"command\": \"hugo --theme=你的主题 --baseURL=\\\"你的站点\\\" \u0026\u0026 cd public \u0026\u0026 git add . \u0026\u0026 git commit -m \\\"Commit message\\\" \u0026\u0026 git push \u0026\u0026 cd ..\", \"group\": { \"kind\": \"build\", \"isDefault\": true }, \"presentation\": { \"reveal\": \"always\", \"panel\": \"shared\", \"showReuseMessage\": false, \"clear\": false }, \"problemMatcher\": [] } ","date":"2023-12-21","objectID":"/hugo%E4%B8%80%E9%94%AE%E5%8F%91%E5%B8%83%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:0","tags":[],"title":"hugo一键发布个人博客","uri":"/hugo%E4%B8%80%E9%94%AE%E5%8F%91%E5%B8%83%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["码农日记"],"content":"配置解释 label: 任务名称。 type: 任务类型，这里是 “shell”，意味着它将在 shell 环境下执行。 command: 要执行的命令序列。 hugo --theme=Loveit --baseURL=\"https://onlane.github.io/\"：运行 Hugo 命令来生成站点，使用 Loveit 主题，设置基础 URL 为你的远端仓库地址。 cd public：改变目录到 public。 git add . \u0026\u0026 git commit -m \"Commit message\" \u0026\u0026 git push：将更改添加到 Git 暂存区，提交这些更改，并推送到远程仓库。 cd ..：返回到先前的目录。 group: 将此任务分组到 “build” 类别。 presentation: 控制任务运行时的终端展示方式。 reveal: 设置为 “always”，在任务运行时总是显示终端。 panel: 使用共享的面板。 problemMatcher: 用于匹配输出中的问题，这里设置为空。 Shift+ctrl+P运行命令，选择该任务即可。 ","date":"2023-12-21","objectID":"/hugo%E4%B8%80%E9%94%AE%E5%8F%91%E5%B8%83%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:1","tags":[],"title":"hugo一键发布个人博客","uri":"/hugo%E4%B8%80%E9%94%AE%E5%8F%91%E5%B8%83%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["八股文"],"content":"ACID A:原子性（Atomicity） C：一致性（Consistency） I：隔离性（Isolation） D：持久性（Durability） ","date":"2023-09-16","objectID":"/mysql%E4%BA%8B%E5%8A%A1/:1:0","tags":["DB"],"title":"MySQL事务","uri":"/mysql%E4%BA%8B%E5%8A%A1/"},{"categories":["八股文"],"content":"原子性 不必多说 undo log（回滚日志） 来保证 ","date":"2023-09-16","objectID":"/mysql%E4%BA%8B%E5%8A%A1/:1:1","tags":["DB"],"title":"MySQL事务","uri":"/mysql%E4%BA%8B%E5%8A%A1/"},{"categories":["八股文"],"content":"一致性 就是保证一些不合理的东西不会出现（一般在业务层处理） 比如高考考了1024分。。。。 ","date":"2023-09-16","objectID":"/mysql%E4%BA%8B%E5%8A%A1/:1:2","tags":["DB"],"title":"MySQL事务","uri":"/mysql%E4%BA%8B%E5%8A%A1/"},{"categories":["八股文"],"content":"持久性 每次操作的结果应该永久保留 通过 redo log （重做日志）来保证 ","date":"2023-09-16","objectID":"/mysql%E4%BA%8B%E5%8A%A1/:1:3","tags":["DB"],"title":"MySQL事务","uri":"/mysql%E4%BA%8B%E5%8A%A1/"},{"categories":["八股文"],"content":"隔离性 保证其他的状态转换不会影响到本次的状态转换 MVCC（多版本并发控制） 或锁机制来保证 ","date":"2023-09-16","objectID":"/mysql%E4%BA%8B%E5%8A%A1/:1:4","tags":["DB"],"title":"MySQL事务","uri":"/mysql%E4%BA%8B%E5%8A%A1/"},{"categories":["八股文"],"content":"事务的几个状态 ","date":"2023-09-16","objectID":"/mysql%E4%BA%8B%E5%8A%A1/:2:0","tags":["DB"],"title":"MySQL事务","uri":"/mysql%E4%BA%8B%E5%8A%A1/"},{"categories":["八股文"],"content":"脏读、幻读、不可重复读 ","date":"2023-09-16","objectID":"/mysql%E4%BA%8B%E5%8A%A1/:3:0","tags":["DB"],"title":"MySQL事务","uri":"/mysql%E4%BA%8B%E5%8A%A1/"},{"categories":["八股文"],"content":"脏读 1、在事务A执行过程中，事务A对数据资源进行了修改，事务B读取了事务A修改后的数据。 2、由于某些原因，事务A并没有完成提交，发生了RollBack操作，则事务B读取的数据就是脏数据 ","date":"2023-09-16","objectID":"/mysql%E4%BA%8B%E5%8A%A1/:3:1","tags":["DB"],"title":"MySQL事务","uri":"/mysql%E4%BA%8B%E5%8A%A1/"},{"categories":["八股文"],"content":"不可重复读 事务B读取了两次数据资源，在这两次读取的过程中事务A修改了数据，导致事务B在这两次读取出来的数据不一致。 这种在同一个事务中，前后两次读取的数据不一致的现象就是不可重复读(Nonrepeatable Read) ","date":"2023-09-16","objectID":"/mysql%E4%BA%8B%E5%8A%A1/:3:2","tags":["DB"],"title":"MySQL事务","uri":"/mysql%E4%BA%8B%E5%8A%A1/"},{"categories":["八股文"],"content":"幻读 事务B前后两次读取同一个范围的数据，在事务B两次读取的过程中事务A新增了数据，导致事务B后一次读取到前一次查询没有看到的行 ","date":"2023-09-16","objectID":"/mysql%E4%BA%8B%E5%8A%A1/:3:3","tags":["DB"],"title":"MySQL事务","uri":"/mysql%E4%BA%8B%E5%8A%A1/"},{"categories":["八股文"],"content":"不可重复读和幻读的区别 幻读和不可重复读有些类似，但是幻读强调的是集合的增减，而不是单条数据的更新。 ","date":"2023-09-16","objectID":"/mysql%E4%BA%8B%E5%8A%A1/:3:4","tags":["DB"],"title":"MySQL事务","uri":"/mysql%E4%BA%8B%E5%8A%A1/"},{"categories":["八股文"],"content":"事务的隔离级别 读未提交（read uncommitted），指一个事务还没提交时，它做的变更就能被其他事务看到； 读提交（read committed），指一个事务提交之后，它做的变更才能被其他事务看到； 可重复读（repeatable read），指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别； 串行化（serializable ）；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行； ","date":"2023-09-16","objectID":"/mysql%E4%BA%8B%E5%8A%A1/:4:0","tags":["DB"],"title":"MySQL事务","uri":"/mysql%E4%BA%8B%E5%8A%A1/"},{"categories":["八股文"],"content":"MVCC InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号(system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。 ","date":"2023-09-16","objectID":"/mysql%E4%BA%8B%E5%8A%A1/:5:0","tags":["DB"],"title":"MySQL事务","uri":"/mysql%E4%BA%8B%E5%8A%A1/"},{"categories":["八股文"],"content":"ReadView 可以理解为数据库中某一个时刻所有未提交事务的快照。 ","date":"2023-09-16","objectID":"/mysql%E4%BA%8B%E5%8A%A1/:5:1","tags":["DB"],"title":"MySQL事务","uri":"/mysql%E4%BA%8B%E5%8A%A1/"},{"categories":["八股文"],"content":"undo日志(索引记录的隐藏列) ","date":"2023-09-16","objectID":"/mysql%E4%BA%8B%E5%8A%A1/:5:2","tags":["DB"],"title":"MySQL事务","uri":"/mysql%E4%BA%8B%E5%8A%A1/"},{"categories":["八股文"],"content":"事务访问记录时 一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况： 如果记录的 trx_id 值小于 Read View 中的 min_trx_id 值，表示这个版本的记录是在创建 Read View 前已经提交的事务生成的，所以该版本的记录对当前事务可见。 如果记录的 trx_id 值大于等于 Read View 中的 max_trx_id 值，表示这个版本的记录是在创建 Read View 后才启动的事务生成的，所以该版本的记录对当前事务不可见。 如果记录的 trx_id 值在 Read View 的 min_trx_id 和 max_trx_id 之间，需要判断 trx_id 是否在 m_ids 列表中： 如果记录的 trx_id 在 m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务不可见。 如果记录的 trx_id 不在 m_ids列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务可见。 这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。 ","date":"2023-09-16","objectID":"/mysql%E4%BA%8B%E5%8A%A1/:5:3","tags":["DB"],"title":"MySQL事务","uri":"/mysql%E4%BA%8B%E5%8A%A1/"},{"categories":["八股文"],"content":"MVCC的作用 一句话：实现读已提交和可重复读 可重复读 可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View。 ","date":"2023-09-16","objectID":"/mysql%E4%BA%8B%E5%8A%A1/:5:4","tags":["DB"],"title":"MySQL事务","uri":"/mysql%E4%BA%8B%E5%8A%A1/"},{"categories":["八股文"],"content":"读提交 读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View。 ","date":"2023-09-16","objectID":"/mysql%E4%BA%8B%E5%8A%A1/:5:5","tags":["DB"],"title":"MySQL事务","uri":"/mysql%E4%BA%8B%E5%8A%A1/"},{"categories":["八股文"],"content":"架构 连接器连接用户 看缓存记录里有没有对应记录（8.0删除了）（key是sql语句，value是结果） 分析器词法分析、语法分析-\u003e预处理器看有没有表名字段名、*换成全列名 优化器判断走什么索引，给出计划-\u003e执行器连接存储引擎，返回数据。 引擎 最常用的：InnoDB、MyISAM ","date":"2023-07-08","objectID":"/mysql%E5%88%9D%E8%A7%81/:0:0","tags":["DB"],"title":"MySQL初见","uri":"/mysql%E5%88%9D%E8%A7%81/"},{"categories":["八股文"],"content":"为什么InnoDB替换了MyISAM ①存储方式：MyISAM引擎会将表数据和索引数据分成两个文件存储。 ②索引支持：因为MyISAM引擎的表数据和索引数据是分开的，因此不支持聚簇索引。 ③事务支持：由于MyISAM引擎没有undo-log日志，所以不支持多条SQL组成事务并回滚。 ④故障恢复：MyISAM引擎依靠bin-log日志实现，bin-log中未写入的数据会永久丢失。 ⑤锁粒度支持：因为MyISAM不支持聚簇索引，因此无法实现行锁，所有并发操作只能加表锁。 ⑥并发性能：MyISAM引擎仅支持表锁，所以多条线程出现读-写并发场景时会阻塞。 ⑦内存利用度：MyISAM引擎过于依赖MySQL Server，对缓冲池、异步IO技术开发度不够。 存储架构 InnoDB .frm：表结构 .ibd：表数据 就这两个文件 ","date":"2023-07-08","objectID":"/mysql%E5%88%9D%E8%A7%81/:1:0","tags":["DB"],"title":"MySQL初见","uri":"/mysql%E5%88%9D%E8%A7%81/"},{"categories":["八股文"],"content":"行格式 ","date":"2023-07-08","objectID":"/mysql%E5%88%9D%E8%A7%81/:2:0","tags":["DB"],"title":"MySQL初见","uri":"/mysql%E5%88%9D%E8%A7%81/"},{"categories":["八股文"],"content":"变长字段长度列表 varchar会变，所以需要通过这个字段记录下长度（考虑cache用了小端模式） ","date":"2023-07-08","objectID":"/mysql%E5%88%9D%E8%A7%81/:2:1","tags":["DB"],"title":"MySQL初见","uri":"/mysql%E5%88%9D%E8%A7%81/"},{"categories":["八股文"],"content":"NULL值列表 记录表中NULL值，如果字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了。（可以至少节省1字节空间） ","date":"2023-07-08","objectID":"/mysql%E5%88%9D%E8%A7%81/:2:2","tags":["DB"],"title":"MySQL初见","uri":"/mysql%E5%88%9D%E8%A7%81/"},{"categories":["八股文"],"content":"记录头信息 比如delete标识数据 下一条记录的位置 当前记录的类型 日志 ","date":"2023-07-08","objectID":"/mysql%E5%88%9D%E8%A7%81/:2:3","tags":["DB"],"title":"MySQL初见","uri":"/mysql%E5%88%9D%E8%A7%81/"},{"categories":["八股文"],"content":"Undo-log撤销日志 回滚日志 ","date":"2023-07-08","objectID":"/mysql%E5%88%9D%E8%A7%81/:3:0","tags":["DB"],"title":"MySQL初见","uri":"/mysql%E5%88%9D%E8%A7%81/"},{"categories":["八股文"],"content":"Redo-log重做日志 sql先写内存缓冲区，再写磁盘 为了避免这部分数据丢失，redo应运而生 （写日志是顺序写，比较快，相当于顺序写一遍要干嘛，再按照它处理） ","date":"2023-07-08","objectID":"/mysql%E5%88%9D%E8%A7%81/:4:0","tags":["DB"],"title":"MySQL初见","uri":"/mysql%E5%88%9D%E8%A7%81/"},{"categories":["八股文"],"content":"Bin-log变更日志 比redo-log加了表结构 对于Redo-log、Bin-log两者的区别，主要可以从四个维度上来说： ①生效范围不同，Redo-log是InnoDB专享的，Bin-log是所有引擎通用的。 ②写入方式不同，Redo-log是用两个文件循环写，而Bin-log是不断创建新文件追加写。 ③文件格式不同，Redo-log中记录的都是变更后的数据，而Bin-log会记录变更SQL语句。 ④使用场景不同，Redo-log主要实现故障情况下的数据恢复，Bin-log则用于数据灾备、同步。 ","date":"2023-07-08","objectID":"/mysql%E5%88%9D%E8%A7%81/:5:0","tags":["DB"],"title":"MySQL初见","uri":"/mysql%E5%88%9D%E8%A7%81/"},{"categories":["八股文"],"content":"Relay-log暂存日志 用于主从分离 主库把binlog写到这个日志上，从库通过它回放binlog然后暂存日志 主从分离 ","date":"2023-07-08","objectID":"/mysql%E5%88%9D%E8%A7%81/:6:0","tags":["DB"],"title":"MySQL初见","uri":"/mysql%E5%88%9D%E8%A7%81/"},{"categories":["八股文"],"content":"用途 大概就是写用主机读用分机吧，因为写入表的时候会上锁，这时候不能读就很难受，所以读的操作都交给分机实施，然后每次写完把binlog让分机再做一遍。 ","date":"2023-07-08","objectID":"/mysql%E5%88%9D%E8%A7%81/:7:0","tags":["DB"],"title":"MySQL初见","uri":"/mysql%E5%88%9D%E8%A7%81/"},{"categories":["八股文"],"content":"流程 主机写入binlog——主机执行事务——执行io流——链接logdump线程——写入relay-log——从库读relay-log——回放binlog ","date":"2023-07-08","objectID":"/mysql%E5%88%9D%E8%A7%81/:8:0","tags":["DB"],"title":"MySQL初见","uri":"/mysql%E5%88%9D%E8%A7%81/"},{"categories":["八股文"],"content":"模型 异步复制：主机同步过去了，管你分机跟没跟上 同步复制：我必须保证每个分机都跟上 半同步复制：一个（或几个）分机跟上就行，其他不管 ","date":"2023-07-08","objectID":"/mysql%E5%88%9D%E8%A7%81/:9:0","tags":["DB"],"title":"MySQL初见","uri":"/mysql%E5%88%9D%E8%A7%81/"},{"categories":["八股文"],"content":"关于复制延迟的处理方案 把DELETE拆成分表＋DROP 把大事务拆成小事务 做好分机异步进行数据的工作 做好监控方案（建一个表专门记录时间，两个库该表的时间差就是延迟） ","date":"2023-07-08","objectID":"/mysql%E5%88%9D%E8%A7%81/:10:0","tags":["DB"],"title":"MySQL初见","uri":"/mysql%E5%88%9D%E8%A7%81/"},{"categories":["八股文"],"content":"首先上一个经典JVM图，来自guide哥 这一堆东西看的脑壳疼很久了。。。。 ","date":"2023-07-07","objectID":"/jvm%E5%88%9D%E5%AD%A6%E4%B8%80/:0:0","tags":["JAVA"],"title":"JVM初学（一）","uri":"/jvm%E5%88%9D%E5%AD%A6%E4%B8%80/"},{"categories":["八股文"],"content":"先讲线程私有部分 ","date":"2023-07-07","objectID":"/jvm%E5%88%9D%E5%AD%A6%E4%B8%80/:1:0","tags":["JAVA"],"title":"JVM初学（一）","uri":"/jvm%E5%88%9D%E5%AD%A6%E4%B8%80/"},{"categories":["八股文"],"content":"程序计数器（PC） 它是唯一一个不会出现OOM的区域，因为生命周期固定会随线程结束死亡（大概？ ","date":"2023-07-07","objectID":"/jvm%E5%88%9D%E5%AD%A6%E4%B8%80/:1:1","tags":["JAVA"],"title":"JVM初学（一）","uri":"/jvm%E5%88%9D%E5%AD%A6%E4%B8%80/"},{"categories":["八股文"],"content":"虚拟机栈 由栈帧构成，里面存了操作数，返回地址，局部变量（也就是方法调用能用到的一切东西）。当方法创建时栈帧压入，销毁（return）时，栈帧弹出。 动态链接 简单来说就是个指针指向方法真的在的地方。 下面是复杂的…… 主要服务一个方法需要调用其他方法的场景。在 Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（Symbilic Reference）保存在 Class 文件的常量池里。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用。 StackOverFlowError 当虚拟机栈内存大小无法动态扩展时，栈帧压冒漾了。 OutOfMemoryError（OOM） 当虚拟机栈还是疯狂压栈帧，但是可以动态扩展内存，但是扩展也没处扩展了的时候，就oom了。 ","date":"2023-07-07","objectID":"/jvm%E5%88%9D%E5%AD%A6%E4%B8%80/:1:2","tags":["JAVA"],"title":"JVM初学（一）","uri":"/jvm%E5%88%9D%E5%AD%A6%E4%B8%80/"},{"categories":["八股文"],"content":"本地方法栈 蒙圈了吧，这玩意和虚拟机栈好像啊。 确实，其他的都一模一样，除了这个东西提供的是Native方法服务，不是Java方法。 啊？啥叫Native方法？ 看着玄乎其实就是其他语言的方法接口…… ","date":"2023-07-07","objectID":"/jvm%E5%88%9D%E5%AD%A6%E4%B8%80/:1:3","tags":["JAVA"],"title":"JVM初学（一）","uri":"/jvm%E5%88%9D%E5%AD%A6%E4%B8%80/"},{"categories":["八股文"],"content":"进程里线程共享的部分 ","date":"2023-07-07","objectID":"/jvm%E5%88%9D%E5%AD%A6%E4%B8%80/:2:0","tags":["JAVA"],"title":"JVM初学（一）","uri":"/jvm%E5%88%9D%E5%AD%A6%E4%B8%80/"},{"categories":["八股文"],"content":"GC 见了好多遍这个词，没想到是Garbage Collect，垃圾收集…… ","date":"2023-07-07","objectID":"/jvm%E5%88%9D%E5%AD%A6%E4%B8%80/:2:1","tags":["JAVA"],"title":"JVM初学（一）","uri":"/jvm%E5%88%9D%E5%AD%A6%E4%B8%80/"},{"categories":["八股文"],"content":"（GC）堆 感觉有点过分，这就是1.8后运行时jvm剩下的唯一部分了，此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。 虽然这么说，但垃圾收集器大部分工作都是管理这，所以也被称为垃圾堆。 关于垃圾回收 Java的垃圾回收机制感觉和那个操作系统的时间片轮转异曲同工吧，就是到年龄了就回收 还是看一下1.8前后的变化: 新生代内存(Young Generation) 老生代(Old Generation)：中间这个 永久代(Permanent Generation)：下面这个，1.8改为元空间了，可以回顶部看一眼，元空间在本地内存里，使用直接内存（后面再说）。 小对象会直接出生在Eden区，要是塞不下了就Minor GC（新生代收集）再往S区塞，S不行就往老年区塞。不过一般情况下是熬过一定的MinorGC（有一个动态年龄计算）再往老年塞。 而大对象（比如：字符串、数组，需要连续大量内存）和长期存活的对象就直接往老年区塞了。 GC 分类 部分收集 (Partial GC)： 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集； 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集； 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。 整堆收集 (Full GC)：收集整个 Java 堆和方法区。 空间分配担保 因为清理年轻的会增加老的，所以清理年轻的之前先看一下老的空间够不够大（不够大就full gc） 死亡对象判断 引用计数法 没有引用的时候就判死缓 可达性分析算法 引用了但永远也无法到达的地方……死缓 为什么是死缓（被弃用了就是） ","date":"2023-07-07","objectID":"/jvm%E5%88%9D%E5%AD%A6%E4%B8%80/:2:2","tags":["JAVA"],"title":"JVM初学（一）","uri":"/jvm%E5%88%9D%E5%AD%A6%E4%B8%80/"},{"categories":["八股文"],"content":"堆的OOM 堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如： java.lang.OutOfMemoryError: GC Overhead Limit Exceeded ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。 java.lang.OutOfMemoryError: Java heap space :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过-Xmx参数配置，若没有特别配置，将会使用默认值，详见：Default Java 8 max heap sizeopen in new window) …… ","date":"2023-07-07","objectID":"/jvm%E5%88%9D%E5%AD%A6%E4%B8%80/:2:3","tags":["JAVA"],"title":"JVM初学（一）","uri":"/jvm%E5%88%9D%E5%AD%A6%E4%B8%80/"},{"categories":["不正经论文"],"content":"\r摘要\r初入爱河的人总会想要谈论爱情，逃不开的。 好吧开玩笑的，这是一篇集合了很多书的读后感。算是吧。 又其实，它是演讲稿。 其实是情书 于我而言爱情是人生漫长修行的旅途中的一个不可避免的课题，一场对具体的人施以绝对客体化的同时认识其主体性的竭尽全力，一种明知不可而为之的英雄主义。 没有人可以天生掌握一项能力，从这个概念上来讲爱并不是一个特例，因此爱是需要学习的。但请注意，在此所说的学习与平日我们看到的约会技巧需要做一些差异性的区分（例如”如何让喜欢的人喜欢自己“”三句话让男人为我花了18万“一类），后者所谈论的课题在于如何被爱、如何惹人爱，而不在于爱的能力本身。 爱的能力在某种程度上可以替换为另一个词：建立并维护亲密关系的能力。练习这种能力是一个并不轻松的事情，因此于我而言，我会想要知道爱的意义。 从庞大而冰冷的宏观视角来看，人们千百年来歌颂、谈论这件事大致是为了繁衍生息，当然，也可以说人们因爱而缔结、存续，所以爱使人成为人。可是当爱的范围落到伴侣之爱的区间内就又另当别论了，我们观察历史会发现人们对爱情的看法更像一种社会文化，一种会跟随生产关系变化而变化的普遍价值观：母系氏族社会的大爱、封建父权社会的守贞之爱、资本产生后异化婚姻制所带来的虽然是一对一但明显男女有别的爱（男人嫖娼在当时几乎被默许），发展到今天、伴随着性别平权运动逐渐形成了当下社会默认的浪漫爱（虽然男女其实还是有别吧，只是逐渐不可以放在明面上）（纳西族安达）。 所以爱情不是能具有唯一公理性定义的事务，落到个人上来讲，如果人是自由的，我们就可以选择如何去爱，而选择爱的方式就像选择一种生活的态度，它会塑造我们自己。因此爱是一场自我的修行。 除此以外，克里斯多福所著的《亲密关系》里有这样一种看法：在亲密关系里的很多争吵是因为期望得不到满足，而期望之所以产生往往来源于我们过去受到的创伤。心理学对此有一个普遍的理论是亲密关系是亲子关系的投影，也就是说，人们会在潜意识里寻找与儿时依赖的客体相似的关系，并且重塑创伤场景。可能有些时候我们会发现，经历过的多段情感总是以某种相似的方式开始、经历、结束，可能的原因就在此。而那些创伤其实和眼前这个人没有关系，她理应不必对此负责。 《亲密关系》中有一段话精确地描述了这点：“很多人认为需要某人就等于爱她，因此为‘爱’所苦，这就是问题所在。期望就是通往地狱之路，因为期望会把接受和让人自由等充满爱意的感觉挡在门外，如果我们不能接受别人现在的样子，或不让他们自由的走自己的路，那么我就不是真的爱他们。我只是想从他们身上得到满足，与他们建立亲密关系的目的并不是为了爱，而是为了满足我小小的需求。” 所以真正的爱也许就像那句广为流传的“我是爱你的、你是自由的”——接受亲密伴侣的一切。但这里又带来了一个问题是，接受一切代表了一种“无条件”，而对于一个具体的人，我们说“无论怎样我都爱你”好像也代表了“你是怎样”并不重要，重要的事回到了主体上，变成了“我”爱就可以。 这像是一种抹杀，也就是我最开始说的对具体的人施以绝对客体化，但是我们在亲密关系里（除了假性亲密）对这个人的了解又必然要变得彻头彻尾，也就是充分意识到这个人的核心，甚至进入其潜意识去看到真正的她，我认为没有这些不可以称之为真正的亲密。所以，说回“爱的意义”，人眼中的一切关系都不可避免的是自身在这个世界上的投影，而“爱”是竭尽全力的“无我”，是通过真的去意识到这个人而经历的与社会的连接，是人不再孤独的终极解。 然后我们会发现这个事就变得很像“恋爱脑”，什么无我、什么接受一切，被家暴了还要说爱能止痛是不是，这就又不得不说回爱的学习。与“坠入爱河不会游泳”不同，爱理应是理智的选择，“不是因为我需要你而爱你，而是因为我爱你所以需要你”，换句话说——爱是一种能力。正如那个经典的爱情三角理论所言——激情、亲密和承诺组成了爱情。“坠入爱河”的过程只是一种激情，而变得亲密是双方的努力，承诺更是应该由大脑做出的决定。 所以我觉得爱情真的很像一种艺术，需要学习、练习、天赋、以至于全身心的投入自我。但是这一切都太过理想化了，就像人很难达到真善美，人的有限性使得真正的爱只能成为一种神话。所以与其纸上谈兵不如落到生活里去做，实际点说，尽力而为、享受过程、尊重结果，在其中让彼此成为更好的自己，这就是我目前给出的关于爱情的答卷。 ","date":"2023-06-03","objectID":"/%E7%88%B1%E7%9A%84%E8%89%BA%E6%9C%AF/:0:0","tags":[],"title":"The Art Of Loving","uri":"/%E7%88%B1%E7%9A%84%E8%89%BA%E6%9C%AF/"}]