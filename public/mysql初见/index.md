# MySQL初见

# 架构

&lt;img src=&#34;/image/2.1.png&#34; width = 100%&gt;

1. 连接器连接用户
2. 看缓存记录里有没有对应记录（8.0删除了）（key是sql语句，value是结果）
3. 分析器词法分析、语法分析-&gt;预处理器看有没有表名字段名、*换成全列名
4. 优化器判断走什么索引，给出计划-&gt;执行器连接存储引擎，返回数据。

# 引擎

最常用的：InnoDB、MyISAM

## 为什么InnoDB替换了MyISAM

- ①存储方式：`MyISAM`引擎会将表数据和索引数据分成两个文件存储。
    
- ②索引支持：因为`MyISAM`引擎的表数据和索引数据是分开的，因此不支持聚簇索引。
    
- ③事务支持：由于`MyISAM`引擎没有`undo-log`日志，所以不支持多条`SQL`组成事务并回滚。
    
- ④故障恢复：`MyISAM`引擎依靠`bin-log`日志实现，`bin-log`中未写入的数据会永久丢失。
    
- ⑤锁粒度支持：因为`MyISAM`不支持聚簇索引，因此无法实现行锁，所有并发操作只能加表锁。
    
- ⑥并发性能：`MyISAM`引擎仅支持表锁，所以多条线程出现读-写并发场景时会阻塞。
    
- ⑦内存利用度：`MyISAM`引擎过于依赖`MySQL Server`，对缓冲池、异步`IO`技术开发度不够。
    

# 存储架构

InnoDB

- .frm：表结构
    
- .ibd：表数据
    

就这两个文件

&lt;img src=&#34;/image/2.2.png&#34; width = 70%&gt;


## 行格式

&lt;img src=&#34;/image/2.3.png&#34; width = 100%&gt;


### 变长字段长度列表

varchar会变，所以需要通过这个字段记录下长度（考虑cache用了小端模式）

### NULL值列表

记录表中NULL值，如果字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了。（可以至少节省1字节空间）

### 记录头信息

比如delete标识数据

下一条记录的位置

当前记录的类型

  

# 日志

## Undo-log撤销日志

回滚日志

## Redo-log重做日志

sql先写内存缓冲区，再写磁盘

为了避免这部分数据丢失，redo应运而生

（写日志是顺序写，比较快，相当于顺序写一遍要干嘛，再按照它处理）

## Bin-log变更日志

比redo-log加了表结构

对于`Redo-log、Bin-log`两者的区别，主要可以从四个维度上来说：

- ①生效范围不同，`Redo-log`是`InnoDB`专享的，`Bin-log`是所有引擎通用的。
    
- ②写入方式不同，`Redo-log`是用两个文件循环写，而`Bin-log`是不断创建新文件追加写。
    
- ③文件格式不同，`Redo-log`中记录的都是变更后的数据，而`Bin-log`会记录变更`SQL`语句。
    
- ④使用场景不同，`Redo-log`主要实现故障情况下的数据恢复，`Bin-log`则用于数据灾备、同步。
    

## Relay-log暂存日志

用于主从分离

主库把binlog写到这个日志上，从库通过它回放binlog然后暂存日志

# 主从分离

## 用途

大概就是写用主机读用分机吧，因为写入表的时候会上锁，这时候不能读就很难受，所以读的操作都交给分机实施，然后每次写完把binlog让分机再做一遍。

## 流程

主机写入binlog——主机执行事务——执行io流——链接logdump线程——写入relay-log——从库读relay-log——回放binlog

## 模型

异步复制：主机同步过去了，管你分机跟没跟上

同步复制：我必须保证每个分机都跟上

半同步复制：一个（或几个）分机跟上就行，其他不管

## 关于复制延迟的处理方案

1. 把DELETE拆成分表＋DROP
    
2. 把大事务拆成小事务
    
3. 做好分机异步进行数据的工作
    
4. 做好监控方案（建一个表专门记录时间，两个库该表的时间差就是延迟）

---

> Author: Deequoique  
> URL: http://localhost:1313/mysql%E5%88%9D%E8%A7%81/  

